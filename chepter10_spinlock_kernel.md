自旋锁内核设计

目标：多个CPU同时执行内核，自旋锁来保护数据结构。

10.1 背景需求

内核交互频繁的应用
- 交互性应用
- 大量文件IO
- 频繁缺页错误

不同处理器，不同进程，同时系统调用systemcall。
一种内核，一次执行内核活动的多个线程。
（从原来内核只有一个CPU执行，主从内核，单CPU内核），进化到多个线程提供服务，一个进程内变量交互方便，进程内的互斥比跨进程互斥消耗更多的时间。

锁粒度（granularity）    －－ 使用几个自旋锁，每个锁保护多少数据结构。
＊ 粗粒度（coarse－grained）－－ 少数锁，保护很大一部分。
＊ 细粒毒（fine－grained）  －－ 很多锁，一次保护一个数据结构。

选择哪种锁，要在时间和空间进行权衡。
细粒度自旋锁，需要消耗每个结构体一个字。
粗粒度自旋锁，需要消耗CPU等待时间。
执行简单活动需要多个锁，等待锁的时间太长了。

10.2 巨型锁
giant lock，少量自旋锁，每个锁保护很多数据结构。






